def digital_sort(A):          
    digits = len(hex(max(A))[2:])
    
    for d in range(digits):
        tmp_sorted = A[:]
        A = counting_sort(A, tmp_sorted, d)

    return A


def counting_sort(A, tmp_sorted, d):
    scope = 16
    current_place = 0
    
    offsets = [None] * scope
    C = [0] * scope
    
    for x in A: 
        if x < (scope * d):
            tmp_sorted[current_place] = x
            current_place += 1
        else:
            offset = (x >> (4 * d)) & (scope - 1)
            #offset = x % (10 ** (d + 1)) // (10 ** d)
            C[offset] += 1
        
    counting = 0
    for i in range(scope):
        tmp_sum = C[i] + counting
        offsets[i] = tmp_sum
        counting = tmp_sum
        

    for i in range(len(A) - 1, -1, -1):
        if A[i] >= (scope * d):
            key = (A[i] >> (4 * d)) & (scope - 1)
            #key = A[i] % (10 ** (d + 1)) // (10 ** d)
            if offsets[key] != 0:
                offsets[key] -= 1
                tmp_sorted[current_place + offsets[key]] = A[i]

    return tmp_sorted


from edx_io import edx_io

A = []
B = []
AB = []
result = 0

with edx_io() as io:
    n = io.next_int()
    m = io.next_int()
    length = n * m
    
    for i in range (0, n):
        A.append(io.next_int())
        
    for i in range (0, m):
        B.append(io.next_int())
    
    for a in A:
        for b in B:
            AB.append(a * b)
            
    sorted_ab = digital_sort(AB)

    for i in range(0, length, 10):
        result += sorted_ab[i]

    io.writeln(result)  
